# Протоколы передачи ключей

- Протоколы раздачи ранее сгенерированных ключей
- Протоколы совместной выработки общего ключа
- Схемы предварительного распределения ключей

А также:
- личные протоколы
- протоколы с доверенным центром

### С использованием цифровой подписи

Вопрос аутентификации источника ключа.
Просто подписываешь что надо своей подписью, и всем понятно, что это ты.
Например:
```
A -> B: Eb(K, T), SignA(B, K, T)
or
A -> B: Eb(K, T, SignA(B, K, T))
or
A -> B: T, Eb(A, K), SignA(B, T, Eb(A, K))
```

### Wide-mouth frog

Протокол передачи ключей с третьей стороной.

```
A -> T: A, E_{Kat}(Ta, B, K)
T -> B:    E_{Kbt}(Tt, A, K)
```

Атака:
```
   A -> T:    A, E_{Kat}(Ta, B, K)  -- 1
   T -> B:    E_{Kbt}(Tt, A, K)     -- 1
C(B) -> T:    B, E_{Kbt}(Tt, A, K)  -- 2
   T -> C(A): E_{Kat}(T't, B, K)    -- 2
C(A) -> T:    A, E_{Kat}(T't, B, K) -- 3
   T -> C(B): E_Kbt(T''t, A, K)     -- 3
Next, the real attack:
   A -> C(T): A, E_{Kat}(T'a, B, K)
C(T) -> B:    E_Kbt(T''t, A, K)
```

### Бесключевой Шамира

Метод двух замков и одного контейнера.
Строится на основе коммутирующих функций шифрования, например, возведение в
степень (ДХ).

Атака - банальный МИТМ.

### Нидхема-Шрёдера

```
A -> T: A, B, Ra
T -> A: E_{Kat}(Ra, B, K, E_{Kbt}(K, A))
A -> B: E_{Kbt}(K, A)
B -> A: Ek(Rb)
A -> B: Ek(Rb - 1)
```

Атака - третий шаг можно переиспользовать.

Модификация Denning-Sacco:
```
A -> T: A, B
T -> A: E_{Kat}(B, K, T, E_{Kbt}(K, A, T))
A -> B: E_{Kbt}(K, A, T)
```

### Kerberos

Модификация NS. Базовый:
```
A -> T: A, B, Ra
T -> A: E_{Kat}(K, Ra, L, B), ticket
A -> B: ticket, auther
B -> A: Ek(T, Kb)
where
  ticket = E_{Kbt}(K, A, L)
  auther = Ek(A, T, Ka)
  T - current time
  L - ticket lifetime
```
В протоколе есть два Т: AS и TGS.
AS выдаёт тикеты только для общения с TGS,
а TGS выдаёт тикеты для общения со всеми остальными.

### EKE

У юзера и сервера есть пароль _Р_. Генерируется "соль" _Z_.
```
U -> S: Ep(Z)
S -> U: Ep(Ez(K))
U -> S: Ek(Ru)
S -> U: Ek(Ru, Rs)
U -> S: Ek(Rs)
```
В конце стороны аутентифицированы и ключом К можно пользоваться.

# Распределение ключей

Вместо распределения и хранения ключей, раздаётся ключевая информация, из
которой можно дерайвить ключ по публичным параметрам хостов.

Схема должна быть устойчивой относительно компрометации части ключей
(в следствие кражи или сговора злоумышленных пользователей),
и иметь возможность расширения.

### Формальности

Ai - хосты  
K - ключи  
P - исходные ключевые материалы  
Q - значения ключевых материалов хостов  
R - значения открытой информации о хостах  

Схема на n абонентов: S(n) = (K, P, Q, R, **A0**, **A1**) задаётся двумя алгоритмами:
1. **A0** : P x R -> Q - формирование секретных ключевых материалов
2. **A1** : Q x R -> K - вычисление ключа хоста из его открытой информации и
секретного материала

Схема устойчива к m-кратой компрометации (к сговору m хостов),
если из ключевых материалов m хостов нельзя получить материалы остальных.

Черёмушкин, стр. 192 - необходимое и достаточное условие стойкости.

### KDP схема

n - число абонентов, K - множество секретных ключей.
Выберем какие-то ключи S, |S| = q. Выберем {S1, ..., Sn} - семейство подмножеств S.
i-му абоненту выдаются ключи из Si.  
Когда i-й и j-й абоненты хотят связаться,
то они комбинируют все ключи из пересечения Si /\ Sj и используют его.

Если все пересечения уникальны, т.е.
`forall i j k. Si /\ Sj <= Sk  ->  i = k or j = k`,
то эту схему называют KDP(n, q) схемой.

Там теоремы про семейства Шпернера:
что у нас кдп-схема если пересечения образуют семейство Шпернера.
Доказательство довольно простое (и не приведено в учебнике).
И дальше про количество ключей у каждого абонента.
Черёмушкин, стр. 197-198.

### Схема Блома

F - конечное поле,
r1, ... rn - различные в F - открытая информация о хостах.
Выбираем `f(x, y) = sum[s from 0 to m] sum[t from 0 to m] Ast * x^s * y^t`,
причём Ast = Ats - секреты и недоступны хостам.
Заметим, что `f(x, y) = f(y, x)`.

Ключевые материалы - многочлены (к-ты) `gi(x) = f(x, ri)`.

Там большая теорема о стойкости с матрицами и определителем Ван Дер Монда.
Черёмушкин, стр. 194-195.

# Открытое распределение ключей

Протокол выработки общего ключа при обмене сообщениями по открытому каналу.
Перед выработкой хорошо бы ещё аутентифицироваться -
получится аутентифицированный проткол обмена ключами.

Условия безопасности протокола:
* когда стороны принимают идентификаторы друг друга,
  записи в сообщениях обеими сторонами осуществляются правильно
  (что это, мать его, значит?)
* никто кроме сторон не может определить передаваемый ключ

Ещё хорошо бы иметь защиту от чтения назад,
чтоб ключи были независимы,
чтоб подтверждение верности ключа было автоматическим (G8),
защита идентификаторов.

### DH

Все мы его знаем, и знаем как митмить.

Static DH - всегда одни и те же дх-параметры для одного участника,
но они подписаны специальным центром сертификации.

#### MTI

У сторон есть ещё секретные параметры a и b, и открытые сертификаты w^a и w^b.
После обмена параметрами дх их нужно возвести в степень своего секретного
параметра и умножить на сертификат пира в степени своего дх-показателя.

Атака:
```
let w^c = (w^b)^e in
A -> C(B): A, w^a, SignT(A, w^a), w^x
C -> B:    C, w^c, SignT(C, w^с), w^x
B -> C:    B, w^b, SignT(B, W^b), w^y
C(B) -> A: B, w^b, SignT(B, W^b), w^ye
```
В итоге у А с С(В) и у С с В один и тот же ключ,
и А общается с В, а В отвечает как для С, и С может это прослушать.

### STS

Диффи-хелман, только все сообщения подписаны сертификатами сторон.

Атака возможна, если сообщения подписываются не целиком, а кусками, и камон.
Но это есть в билетах, так что вот атака Лоу, додумывай, сука:
```
   A -> C(B): A, B, w^x
   C -> B:    C, B, w^x
   B -> C:    B, C, w^y, Ek(Sign_B(w^y, w^x))
C(B) -> A:    B, A, w^y, Ek(Sign_B(w^y, w^x))
   A -> C(B): A, B, Ek(Sign_B(w^x, w^y))
```
И дальше у нас нет к, так что максимум атака мусором от имени В.

### DHKE

```
A -> B: w^x, SignA(w^x, B), certA
B -> A: w^y, R, SignB(w^x, w^y, R, A), certB
A -> B: k' = Hr(w^xy) -- для проверки и аутентификации
```

Атака, два атакующих:
```
A -> C: w^x, SignA(w^x, C), certA -- 1
C -> D: A, B, w^x
D -> B: w^x, SignD(w^x, B), certD            -- 2
B -> D: w^y, R, SignB(w^x, w^ym R, D), certB -- 2
D -> C: B, A, w^y, R
C -> A: w^y, SignC(w^x, w^y, R, A), certC -- 1
A -> C: k' -- 1
C -> D: k'
D -> B: k' -- 2
```
Нарушение свойства аутентификации ключа.
