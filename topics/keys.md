# Протоколы передачи ключей

- Протоколы раздачи ранее сгенерированных ключей
- Протоколы совместной выработки общего ключа
- Схемы предварительного распределения ключей

А также:
- личные протоколы
- протоколы с доверенным центром

### С использованием цифровой подписи

Вопрос аутентификации источника ключа.
Просто подписываешь что надо своей подписью, и всем понятно, что это ты.
Например:
```
A -> B: Eb(K, T), SignA(B, K, T)
or
A -> B: Eb(K, T, SignA(B, K, T))
or
A -> B: T, Eb(A, K), SignA(B, T, Eb(A, K))
```

### Wide-mouth frog

Протокол передачи ключей с третьей стороной.

```
A -> T: A, E_{Kat}(Ta, B, K)
T -> B:    E_{Kbt}(Tt, A, K)
```

Атака:
```
   A -> T:    A, E_{Kat}(Ta, B, K)  -- 1
   T -> B:    E_{Kbt}(Tt, A, K)     -- 1
C(B) -> T:    B, E_{Kbt}(Tt, A, K)  -- 2
   T -> C(A): E_{Kat}(T't, B, K)    -- 2
C(A) -> T:    A, E_{Kat}(T't, B, K) -- 3
   T -> C(B): E_Kbt(T''t, A, K)     -- 3
Next, the real attack:
   A -> C(T): A, E_{Kat}(T'a, B, K)
C(T) -> B:    E_Kbt(T''t, A, K)
```

### Бесключевой Шамира

Метод двух замков и одного контейнера.
Строится на основе коммутирующих функций шифрования, например, возведение в
степень (ДХ).

Атака - банальный МИТМ.

### Нидхема-Шрёдера

```
A -> T: A, B, Ra
T -> A: E_{Kat}(Ra, B, K, E_{Kbt}(K, A))
A -> B: E_{Kbt}(K, A)
B -> A: Ek(Rb)
A -> B: Ek(Rb - 1)
```

Атака - третий шаг можно переиспользовать.

Модификация Denning-Sacco:
```
A -> T: A, B
T -> A: E_{Kat}(B, K, T, E_{Kbt}(K, A, T))
A -> B: E_{Kbt}(K, A, T)
```

### Kerberos

Модификация NS. Базовый:
```
A -> T: A, B, Ra
T -> A: E_{Kat}(K, Ra, L, B), ticket
A -> B: ticket, auther
B -> A: Ek(T, Kb)
where
  ticket = E_{Kbt}(K, A, L)
  auther = Ek(A, T, Ka)
  T - current time
  L - ticket lifetime
```
В протоколе есть два Т: AS и TGS.
AS выдаёт тикеты только для общения с TGS,
а TGS выдаёт тикеты для общения со всеми остальными.

### EKE

У юзера и сервера есть пароль _Р_. Генерируется "соль" _Z_.
```
U -> S: Ep(Z)
S -> U: Ep(Ez(K))
U -> S: Ek(Ru)
S -> U: Ek(Ru, Rs)
U -> S: Ek(Rs)
```
В конце стороны аутентифицированы и ключом К можно пользоваться.

# Распределение ключей

Вместо распределения и хранения ключей, раздаётся ключевая информация, из
которой можно дерайвить ключ по публичным параметрам хостов.

Схема должна быть устойчивой относительно компрометации части ключей
(в следствие кражи или сговора злоумышленных пользователей),
и иметь возможность расширения.

### Формальности

Ai - хосты  
K - ключи  
P - исходные ключевые материалы  
Q - значения ключевых материалов хостов  
R - значения открытой информации о хостах  

Схема на n абонентов: S(n) = (K, P, Q, R, **A0**, **A1**) задаётся двумя алгоритмами:
1. **A0** : P x R -> Q - формирование секретных ключевых материалов
2. **A1** : Q x R -> K - вычисление ключа хоста из его открытой информации и
секретного материала

Схема устойчива к m-кратой компрометации (к сговору m хостов),
если из ключевых материалов m хостов нельзя получить материалы остальных.

Черёмушкин, стр. 192 - необходимое и достаточное условие стойкости.

### Схема Блома

F - конечное поле,
r1, ... rn - различные в F - открытая информация о хостах.
Выбираем `f(x, y) = sum[s from 0 to m] sum[t from 0 to m] Ast * x^s * y^t`,
причём Ast = Ats - секреты и недоступны хостам.
Заметим, что `f(x, y) = f(y, x)`.

Ключевые материалы - многочлены (к-ты) `gi(x) = f(x, ri)`.

Там большая теорема о стойкости с матрицами и определителем Ван Дер Монда.
Черёмушкин, стр. 194-195.
