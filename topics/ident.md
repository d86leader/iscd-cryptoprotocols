# Протоколы идентификации

Протокол установления подлинности сторон, один из видов аутентификации.
Состоит из двух участников: доказывающего и проверяющего.

### Классификация
- Односторонние и взаимные: доказывает один другому или оба друг другу
- По уникальным данным:
  * известная обеим сторонам информация
  * физические приборы: карты, ключи
  * физические характеристики: отпечатки, сетчатка
- По шагам:
  * Одношаговые (пароли)
  * Запрос-ответ (двухшаговые)
  * Доказательство знания (трёхшаговые)
  * Доказательство знания с нулевым разглашением (многошаговые)

## Использование паролей

Ну это пароли. Они фиксированные при каждом входе.

Атаки:
- Кража пароля
- Воспроизведение трафика
- Полный перебор
- Словарный перебор

### Защита паролей

- Защита хранимых: зашифрование или хэширование, возможно с солью
- Для перебора: увеличение длины и усложение правила придумывания паролей
- При компрометации базы данных: двойное хэширование (на клиенте и сервере).
  Тут выше в Черёмушкине предполагалось, что хэшируется только на клиенте, ну лол.
- От воспроизведения: передача с временем или использование одноразовых паролей

## Запрос-ответ

Дать ответ на вопрос с помощью своих секретных данных.

### На симметричных шифрах
У сторон общий секретный ключ, и одна сторона просит другую сторону зашифровать
сообщение, а потом расшифровывает и проверяет корректность.
В этом сообщении лучше всего иметь отметку времени, нонс и метки сторон себя.

### На асимметричных
Доказательство личности либо расшифрованием запроса, либо подписыванием запроса.
Запросы те же что и выше.

### На сертификатах
Послать свой сертификат, метку времени, нонс, и что-то подписать.
Если нет метки времени, то можно просто перехватить сообщения и зареплеить.


## Атаки

R - random, E - encrypt, D - decrypt (sign)

### Woo-Lam
[source](https://en.bmstu.wiki/Woo-Lam_(protocol))

```
A -> B: A
B -> A: Rb
A -> B: E_{Kas}(Nb) = Aid
B -> S: E_{Kbs}(A, Aid)
S -> B: E_{Kbs}(Rb)
```

Parallel session attack:
```
C(A) -> B:    A  -- 1
B    -> C(A): Rb -- 1
C    -> B:    X  -- 1

C    -> B:    C           -- 2
B    -> C:    R'b         -- 2
C    -> B:    E_{Kcs}(Rb) -- 2

B    -> S:    E_{Kbs}(A, X)   -- 1
B    -> S:    E_{Kbs}(C, Cid) -- 2
S    -> B:    E_{Kbs}(Rb) -- 2 interpreted by B as 1
```

Mirroring attack:
```
C(A) -> B:    A
B    -> C(A): Rb
C(A) -> B:    Rb
B    -> C(S): E_{Kbs}(A, Rb)
C(S) -> B:    E_{Kbs}(A, Rb)
```
Тут модифицированный протокол, где сервер посылает ещё и личность того, кого он
расшифровывает.

### NSPK

```
A -> B: Eb(Ra, A)
B -> A: Ea(Ra, Rb)
A -> B: Eb(Rb)
```

Attack:
```
A    -> C:    Ec(Ra, A)
C(A) -> B:    Eb(Ra, A)
B    -> C(A): Ea(Ra, Rb)
C    -> A:    Ea(Ra, Rb)
A    -> C:    Ec(Rb)
C(A) -> B:    Eb(Rb)
```

### Neuman-Stubblebine

```
A -> B: A, Ra
B -> T: B, Rb, Eb(A, Ra, Tb)
T -> A: Ea(B, Ra, K, Tb), Eb(A, K, Tb), Rb
A -> B: Eb(A, K, Tb), Ek(Rb)
```

Attack:
```
C(A) -> B:    A, K
B    -> C(T): B, Rb, Eb(A, K, Tb)
C(A) -> B:    Eb(A, K, Tb), Ek(Rb)
```

### ISO and Wiener

```
A -> B: A, Ra
B -> A: Rb,  A, Db(Rb, Ra,  A)
A -> B: R'a, B, Da(Ra, R'a, B)
```

Attack:
```
C(A) -> B:    A, Rc
B    -> C(A): Rb, A, Db(Rb, Rc, A)
C(B) -> A:    B, Rb
A    -> C(B): Ra, B, Da(Ra, Rb, A)
C(A) -> B:    R'a, B, Da(Ra, Ra, B)
```
Я хз, какое-то говно непротокольное. И это даже не называется Винером.

## S/KEY
[source](https://en.wikipedia.org/wiki/S/KEY)

## CHAP
```
A -> B: A
B -> A: R
A -> B: H(R <> S) -- B checks correctness
```

## SecurID
[source](https://en.wikipedia.org/wiki/RSA_SecurID)

Девайс генерирует новые коды безопасности каждую минуту/час/промежуток времени.
При аутентификации нужно ввести свой айди и текущий код.
